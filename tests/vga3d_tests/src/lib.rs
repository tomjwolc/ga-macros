use ga_macros::*;

#[test]
pub fn simple_numbers() {
    assert_eq!([3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(3));
    assert_eq!([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(0));
    assert_eq!([-3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(-3));
    assert_eq!([-3.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(-3.1));
}

#[test]
pub fn implicit_multiplication() {
    assert_eq!([0.0, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(3e1));
    assert_eq!([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 3.0], eq!(3e012));
    assert_eq!([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(0e0));
    assert_eq!([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(0e012));
    assert_eq!([0.0, 0.0, -3.0, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(-3e1));
    assert_eq!([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -3.0], eq!(-3e012));
}

#[test]
pub fn linear_combinations() {
    assert_eq!([1.0, -2.1, 3.0, -4.0, 0.0, 0.0, -3.0, 0.0], eq!(3e1 + -4e2 - 1 - 3e12 + -2.1e0 + 2));
}

#[allow(dead_code)]
pub struct A { a: [f64; len!()] }

#[test]
pub fn weird_inputs() {
    let a = A { a: eq!(1.1) };
    let b: Vec<[f64; len!()]> = vec![eq!(1.2e0)];
    let c = (eq!(1.3e1), eq!(1.4e2));
    let d = |e: f64, f: f64| eq!(#e * e01 + #f * e02);

    assert_eq!([1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 0.0, 0.0], eq!(a.a + b[0] + c.0 + c.1 + d(1.5, 1.6)));
}

#[test]
pub fn github_examples() {
    let a = eq!(3e0 + -2e12);     // -> let a = {[0.0, 3.0, 0.0, 0.0, 0.0, 0.0, -2.0, 0.0]};
    let b = eq!(2 - 6e1 + e12);   // -> let b = {[2.0, 0.0, -6.0, 0.0, 0.0, 0.0, 1.0, 0.0]};
    assert_eq!([2.0, 3.0, -6.0, 0.0, 0.0, 0.0, -1.0, 0.0], eq!(a + b));           // -> println!("{:?}", {[a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3], a[4] + b[4], a[5] + b[5], a[6] + b[6], a[7] + b[7]]});

    let f = |a: f64| eq!(#a + #a * e1);   // -> let f = |a: f64| {[a, 0.0, a, 0.0, 0.0, 0.0, 0.0, 0.0]}
    let arr = vec![eq!(5e1 + 2e01 + 4e12)];   // -> let arr = vec![{[0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 4.0, 0.0]}]
    assert_eq!([0.0, 0.0, 3.0, 0.0, 2.0, 0.0, 4.0, 0.0], eq!(f(3.0) @ 1 + arr[0] @ 2));            // -> println!("{:?}", {[0.0, f(3)[1], f(3)[2], f(3)[3], arr[0][4], arr[0][5], arr[0][6], 0.0]})

    assert_eq!("{[0.0, 3.0, 0.0, 0.0, 0.0, 0.0, -2.0, 0.0]}", eq_peek!(3e0 + -2e12)); 
    assert_eq!("{[2.0, 0.0, -6.0, 0.0, 0.0, 0.0, 1.0, 0.0]}", eq_peek!(2 - 6e1 + e12)); 
    assert_eq!("{[a[0]+b[0], a[1]+b[1], a[2]+b[2], a[3]+b[3], a[4]+b[4], a[5]+b[5], a[6]+b[6], a[7]+b[7]]}", eq_peek!(a + b));      

    assert_eq!("{[(a as f64), 0.0, (a as f64), 0.0, 0.0, 0.0, 0.0, 0.0]}", eq_peek!(#a + #a * e1));  
    assert_eq!("{[0.0, 0.0, 5.0, 0.0, 2.0, 0.0, 4.0, 0.0]}", eq_peek!(5e1 + 2e01 + 4e12));  
    assert_eq!("{[0.0, f(3.0)[1], f(3.0)[2], f(3.0)[3], arr[0][4], arr[0][5], arr[0][6], 0.0]}", eq_peek!(f(3.0) @ 1 + arr[0] @ 2));  

    let x: usize = 5;
    let y = eq!(e1);
    assert_eq!([0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(#x * y))
}

#[test]
pub fn functions() {
    assert_eq!([0.0, 0.6, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0], eq!(norm(3e0 + 4e1)))
}